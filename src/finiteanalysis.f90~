module finiteanalysis

	use readmesh
	use elementcalculations

	implicit none
	contains
	
    subroutine getmeshdata(meshdetails,vertices,connectivity,domainelements,surfacenames,surfacefaces)
        integer,parameter :: unitnumber = 111
		integer,dimension(7) :: meshdetails
        integer,dimension(:,:),allocatable :: connectivity, surfacefaces
        integer,dimension(:),allocatable :: domainelements
        character(len=16),dimension(:),allocatable :: surfacenames
        double precision,dimension(:,:),allocatable :: vertices
        double precision,dimension(:),allocatable :: boundaryvalues

        call openmeshfile(unitnumber, 'a.msh')
        call readmeshdetails(unitnumber, meshdetails)
        call readmeshvertices(unitnumber, meshdetails, vertices)
        call readmeshconnectivity(unitnumber, meshdetails, connectivity)
        call readmeshdomains(unitnumber, meshdetails, domainelements)
        call readmeshsurfaces(unitnumber,meshdetails,surfacefaces,surfacenames)
        call closemeshfile(unitnumber)
    end subroutine getmeshdata

    subroutine readboundaryconditions(meshdetails, boundaryconditions, &
    kvals, boundaryvalues, Tambient, generation, generationrate)
        integer,parameter :: datafilenum=222
        character(len=*),parameter :: filename='datafile.dat'
        integer,dimension(7) :: meshdetails
        integer :: numdomains,numboundaries,i,j
        logical :: generation
        integer,dimension(:),allocatable :: boundaryconditions
        double precision :: Tambient
		double precision,optional :: generationrate
        double precision,dimension(:),allocatable :: kvals,boundaryvalues

        numdomains = meshdetails(6)
        numboundaries = meshdetails(7)
		allocate(boundaryconditions(numboundaries))
		allocate(kvals(numdomains))
		allocate(boundaryvalues(numboundaries))
        boundaryvalues = 0.0d0
        boundaryconditions = 4
        open(datafilenum,file=filename,status='old')
        read(datafilenum,*)
        read(datafilenum,*)
        do i=1,numdomains
			read(datafilenum,*)
            read(datafilenum,*) kvals(i)
        end do
		read(datafilenum,*)
        read(datafilenum,*) boundaryconditions
        read(datafilenum,*)
        read(datafilenum,*) boundaryvalues
        read(datafilenum,*)
        read(datafilenum,*) Tambient
        read(datafilenum,*)
        read(datafilenum,*) generation
        if(generation) then
            read(datafilenum,*)
            read(datafilenum,*) generationrate
        end if
    end subroutine readboundaryconditions

	subroutine finitesolution()
		integer,parameter :: volfilnum=777,spfilnum=888,resfilnum=999,vertfilnum=666,gstfilnum=444
		integer :: numno,numel,numdo,numsu,		&				! Meshdetails
				i,j,k,l,n1,n2,eldom,bface,fbtype				! Counters
		integer,dimension(7) :: mdets							! Always the same size
		integer,dimension(4) :: elnodes							! Tetrahedral mesh
		integer,dimension(3) :: fcnodes							! Triangular faces
		integer,dimension(:),allocatable :: domel,bcs
		integer,dimension(:,:),allocatable :: conn,sfacs
		integer,dimension(17) :: brc=0
		double precision :: elvol,bv,facar,Tamb,gval,hval,elk,pz	! From the data file
		double precision,dimension(4) :: elf,elq,hta,vbs,gcontrib
		double precision,dimension(4,3) :: ec,gr
		double precision,dimension(4,4) :: sp,btdb,ntn
		double precision,dimension(3) :: point
		double precision,dimension(:),allocatable :: kvals,bvals,gF,Tvals,newF
		double precision,dimension(:,:),allocatable :: ver,gK,newK
		character(len=*),parameter :: outputdir="/home/anupam/Documents/ConductionFEM/ConductionFEM/obj/",	&
									volfil=outputdir//"volumes.out",spfil=outputdir//"spfuncs.out",			&
									resfil=outputdir//"results.out",vertfil=outputdir//"vertices.out",		&
									gstfil=outputdir//"globalstiffness.out"
		character(len=16), dimension(:), allocatable :: sfacnam
        logical :: gen
		
		call getmeshdata(mdets,ver,conn,domel,sfacnam,sfacs)
		print *, "meshdetails received"
		numno = mdets(1)
		numel = mdets(2)
		numdo = mdets(6)
		numsu = mdets(7)
		allocate(gF(numno))
		allocate(Tvals(numno))
		allocate(gK(numno,numno))
		gF = 0.0d0
		gK = 0.0d0
		Tvals = 0.0d0
        call readboundaryconditions(mdets,bcs,kvals,bvals,Tamb,gen)
		open(volfilnum,file=volfil)
		open(spfilnum,file=spfil)
		open(resfilnum,file=resfil)
		open(vertfilnum,file=vertfil)

		open(345,file=outputdir//"sfacs.out")

		print *, "BCs: ", bcs
		do i=1,numel
			elnodes = conn(i,:)
			eldom = domel(i)
			ec = ver(elnodes,:)
			write(vertfilnum,*) "Element number: ", i			
			do j=1,4
				write(vertfilnum,'(3(f8.5,2x))') ec(j,:)
			end do
			call shapefunctions(ec,elvol,sp)
			write(volfilnum,'(i8,2x,f8.5)') i,elvol
			write(spfilnum,*) "Element number: ", i
			do j=1,4
				write(spfilnum,'(4(f8.5,2x))') sp(j,1:4)
			end do

			elk = kvals(eldom)
			call elementstiffness(sp,elvol,elk,btdb)
			do j=1,4
				n1 = elnodes(j)
				do k=1,4
					n2 = elnodes(k)
					gK(n1,n2) = gK(n1,n2) + btdb(j,k)
				end do
			end do
			do j=1,4
				if(sfacs(i,j) /= 0) then
					if(i==23) then
						print *, "sfacs: ", sfacs(i,:)
					end if
					bface = sfacs(i,j)
					fbtype = bcs(bface)
					bv = bvals(bface)
					if(fbtype == 1) then
						call bfacenodes(i,elnodes,j,fcnodes)
						do k=1,3
							Tvals(fcnodes(k)) = bv
						end do
					elseif(fbtype == 2) then
						call fluxboundary(i,elnodes,sp)
					elseif(fbtype == 3) then
						call convectionboundary(i,elnodes,sp)
					else
						continue
					end if
				end if
			end do
			if(gen) then
				call uniformgeneration(gval,elvol,gcontrib)
				do j=1,4
					gF(elnodes(j)) = gF(elnodes(j)) + gcontrib(j)
				end do 
			end if
			do k=1,17
				pz = 2.0d0 + 123.0d0*(k-1)*(1.0d0/16.0d0)
				point = (/50.0d0,50.0d0,pz/)
				call barycentric(point,ec,vbs)
				if(minval(vbs) .ge. 0.0d0 .and. maxval(vbs) .le. 1.0d0) then
!!					print *, "element number: ", i
!!					write(*,'(a,4x,3(f8.5,2x))') "point: ", point
!					do j=1,4
!						write(*,'(3(f8.5,2x))') ec(j,:)
!					end do
					if(maxval(vbs).gt.0.9999999999d0 .and. brc(k).ne.0) then
						cycle
					end if
					brc(k) = i
				end if
			end do
		end do

		open(gstfilnum,file=gstfil)		
		do i=1,numno
			write(gstfilnum,'(56(f8.3,2x))') gK(i,:)
		end do
		write(gstfilnum,*) "End of global stiffness."

		do i=1,numno
			write(gstfilnum,'(f7.3)') Tvals(i)
		end do
		
		do i=1,numno
			write(resfilnum,'(f5.1)') Tvals(i)
		end do
		write(resfilnum,*) "End of Temperature."

		call setupfinalequations(gK,Tvals,gF,newK,newF)
		write(resfilnum,*) " "		

		call solvefinalequations(newK,newF)

		write(resfilnum,*) " "		
		write(resfilnum,*) "Small results begin"
	
		do i=1,numno
			write(resfilnum,'(f8.2)') newF(i)
		end do

		write(resfilnum,*) " "
		write(resfilnum,*) "Elements containing points on the x=1, y=0 plane"
		do i=1,17
			write(resfilnum, '(i8)') brc(i)
		end do

	end subroutine finitesolution

	subroutine setupfinalequations(gK,Tvals,gF,newK,newF)
		double precision,dimension(:,:) :: gK
		double precision,dimension(:) :: Tvals,gF
		double precision,dimension(:,:),allocatable :: newK
		double precision,dimension(:),allocatable :: newF
		double precision,parameter :: small=1e-6
		integer :: i,j,k,knT,unT,n
		
		n=size(gK,1)
		allocate(newK(n,n))
		allocate(newF(n))
		newF = gF
		newK = gK
		knT = 0
		unT = 0
		
		do i=1,n
			if(abs(Tvals(i)) < small) then
				unT = unT+1
				newF(i) = newF(i) - dot_product(newK(i,:),Tvals)
				do j=1,n
					if(abs(Tvals(j)) > small) then
						newK(i,j) = 0.0d0
					end if
				end do
			else
				knT = knT+1
				newF(i) = Tvals(i)
				newK(i,:) = 0.0d0
				newK(i,i) = 1.0d0
			end if
		end do
		
		print *, "Known and unknown: ", knT, unT
	end subroutine setupfinalequations
	
	subroutine solvefinalequations(K,F)
		double precision,dimension(:,:) :: K
		double precision,dimension(:) :: F
		integer :: m,n,nrhs,lda,ldb,info
		integer,dimension(size(K,1)) :: ipiv
		character(len=1) :: trans="N"

		m = size(K,1)
		n = size(K,1)
		lda = size(K,1)
		ldb = size(K,1)
		nrhs = 1
		call dgetrf(m,n,K,lda,ipiv,info)
		call dgetrs(trans,n,nrhs,K,lda,ipiv,F,ldb,info)

	end subroutine solvefinalequations

	subroutine barycentric(p,ec,vbs)
		double precision,dimension(4,3) :: ec
		double precision,dimension(4,4) :: vm
		double precision,dimension(3) :: p
		double precision,dimension(4) :: vbs
		double precision :: ev
		integer :: i,j,k

		vm(:,2:4) = ec
		vm(:,1) = 1.0d0
		ev = det4(vm)
		do i=1,4
			vm(:,2:4) = ec
			vm(i,2:4) = p
			vbs(i) = det4(vm)/ev
		end do

	end subroutine barycentric

	subroutine uniformgeneration(gval,elvol,gcontrib)
		double precision :: gval,elvol
		double precision,dimension(4) :: gcontrib

		gcontrib = (gval*(elvol/6.0d0)/4)*(/1,1,1,1/)
	end subroutine uniformgeneration
end module finiteanalysis
